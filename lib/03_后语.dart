import 'dart:async';

import 'package:flutter/material.dart';

class AfterWidget extends StatefulWidget {
  const AfterWidget({Key? key}) : super(key: key);

  @override
  State<AfterWidget> createState() => _AfterWidgetState();
}

class _AfterWidgetState extends State<AfterWidget> {
  @override
  void initState() {
    super.initState();

    // immediateTask();
    // macroTask();
    microTask();
  }

  @override
  Widget build(BuildContext context) {
    return const Placeholder();
  }
}

/*
  一、进程和线程
  进程就是指操作系统上正在运行的应用程序，一个正在运行的应用程序就是一个进程

  线程就是指一段代码从头到尾的【执行路径】，具体地说比如我们编写的OC代码最终都会被编译成二进制代码供CPU执行，那么CPU在执行这些二进制代码时是从上往下一行一行串行执行的，
  当遇见if语句或for语句等控制语句时，CPU会偏离当前地址处的二进制代码去执行其它地址处的二进制代码，但执行完后又会返回来执行当前地址处的二进制代码，直到二进制代码执行完毕，
  这样一段代码从头到尾的执行路径就被称为一个线程

  每个进程中至少会有一条线程，这个线程被称为主线程
 */

/*
  二、单线程和多线程
  单线程就是指进程里”只有一条“主线程（Dart被设计为单线程的，但是我们可以通过isolate来实现多线程开发、以免阻塞主线程，类似于JS里的workers，
  不过isolate和workers与传统多线程不完全一样，它们不能直接访问主线程里的数据，只能通过消息传递的方式与主线程进行通信
  但其实每个App的进程里除了主线程外，还有一些其它的默认线程，所以并不是绝对的单线程）

  而开辟一个新线程就是指把某段代码的执行路径和另一段代码的执行路径给完全独立开来，成为CPU的一个单独调度单位，所以当一个进程中有多个这样独立的代码的执行路径时，就是多线程。
  使用多线程的好处是可以提高程序的执行效率，使用多线程的坏处是开辟过多的线程会占用大量内存和CPU资源，而且还会存在数据竞争问题，因此通常开三到五个线程就差不多了。
  我们都知道一个CPU一次只能调度一个线程，那苹果是怎么实现多线程并发的呢？
  原来苹果会让CPU一会儿执行线程1，一会执行线程2，当线程之间的切换时间足够短时，就让我们感觉CPU是在一次执行多个线程，而现在设备都是多核的了，就不仅仅是“感觉”了，而是真得可以利用多个CPU来实现多线程并发
 */

/*
  三、立即执行事件

  执行下面的代码，我们发现打印为：
  111
  222
  333
  这很正常，我们把不是异步耗时操作的代码都称之为立即执行事件，Flutter引擎在遇到它们时会立即把它们放到主线程里去执行
 */
void immediateTask() {
  debugPrint("111");
  debugPrint("222");
  debugPrint("333");
}

/*
  四、宏任务事件

  执行下面的代码，我们发现打印为：
  111
  222
  333
  延时0s后
  延时5s后

  那这段代码是怎么执行的呢？
  1、Flutter引擎在遇到”console.log(111);“这个立即执行事件时，会立即把它放到主线程里去执行，所以打印了111
  2、Flutter引擎在遇到”setTimeout“时，setTimeout这个函数本身还是个立即执行事件、它携带的那个回调函数本身是个宏任务事件（因为它不会被立即执行、而是会被放到宏任务队列里）、这里的耗时操作实际上是那5s钟的倒计时，
  所以会立即把setTimeout这个函数本身放到主线程里去执行，而执行它的效果就是开启一个定时器开始倒计时5s钟，定时器启动后setTimeout这个函数本身的使命就结束了，于是可以继续执行后面的代码，而不至于阻塞在这里，但是有两个疑问：
    * ① 那为什么不会阻塞在这里呢？
    这是因为Flutter设计这个倒计时操作不是由主线程来倒计时的，而是由其它的默认线程来倒计时的，也就是说主线程不会卡在这一直数5s钟才能往后执行，而是可以立即往后执行
    * ② 那setTimeout函数携带的那个回调函数是怎么处理的呢？
    这个回调函数会一直放在那，直到其它线程里对应的那个倒计时结束，Flutter引擎才会把这个回调函数放到宏任务队列里（注意放进宏任务队列的时机是倒计时结束的那一刻，而不是执行setTimeout函数时就放进去），
    然后这个回调函数就是乖乖等待被调用了，也就是说Flutter引擎在执行完所有的立即执行事件后，才会去宏任务队列里拿宏任务事件来执行，
    【这也是为什么我们说定时器可能不太准的原因，就是因为就算倒计时结束了，回调函数也立即被放进宏任务队列里了，但万一此时有个立即执行事件非常耗时、还没执行完呢，那这个回调函数肯定要等人家执行完才能被执行了，所以有可能会滞后】
  3、Flutter引擎在遇到”console.log(222);“这个立即执行事件时，会立即把它放到主线程里去执行，所以打印了222
  4、Flutter引擎在遇到”setTimeout“时，setTimeout这个函数本身还是个立即执行事件、它携带的那个回调函数本身是个宏任务事件（因为它不会被立即执行、而是会被放到宏任务队列里）、这里的耗时操作实际上是那0s钟的倒计时，
  所以会立即把setTimeout这个函数本身放到主线程里去执行，而执行它的效果就是开启一个定时器开始倒计时0s钟，定时器启动后setTimeout这个函数本身的使命就结束了，于是可以继续执行后面的代码，而不至于阻塞在这里，但是有一个疑问：
    * 延时0s钟、那携带的那个回调函数到底是立即执行事件还是宏任务事件？
    只要用了setTimeout，不管延时多长时间、就算是延时0s钟，携带的那个回调函数也是宏任务事件，
    【所以别看着是延时0s钟就觉得那个回调函数会立即执行，实际上那个回调函数会绕一大圈才被执行————其它线程启动定时器、定时器倒计时结束后那个回调函数被放入宏任务队列、所有的立即执行事件执行完毕后才执行那个回调函数】，所以它肯定会晚于333的执行————因为人家333是个立即执行事件
  5、Flutter引擎在遇到”console.log(333);“这个立即执行事件时，会立即把它放到主线程里去执行，所以打印了333
  6、打印完333，所有的立即执行事件就都执行完了，所以Flutter引擎就会去宏任务队列里拿宏任务事件来执行，而延时0s的那个回调函数是先被放进队列里的，所以会先被执行，延时5s的那个回调函数是后被放进队列里的，所以会后被执行，于是依次打印延时0s后、延时5s后
 */
void macroTask() {
  debugPrint("111");

  Timer(const Duration(milliseconds: 5000), () {
    debugPrint("延时5s后");
  });

  debugPrint("222");

  Timer(const Duration(milliseconds: 0), () {
    debugPrint("延时0s后");
  });

  debugPrint("333");
}

/*
  五、微任务事件

  执行下面的代码，我们发现打印为：
  111
  333
  222
  Flutter.then被触发了

  那这段代码是怎么执行的呢？
  1、Flutter引擎在遇到”console.log(111);“这个立即执行事件时，会立即把它放到主线程里去执行，所以打印了111
  2、Flutter引擎在遇到Future的那段代码时，Future.delayed本身是立即执行事件，它的使命也是启动一个定时器，所以启动完之后它的使命就完成了，所以会立即执行后面的333
    * executor函数里会先打印222，然后执行resolve函数、resolve函数本身是个立即执行函数、它被执行后，Flutter引擎会立即把then监听的第一个函数放到微任务队列里，但是不会立即执行then监听的第一个函数，此时resolve函数的使命就已经完成了，然后继续打印333
  3、打印完333后，Flutter引擎发现定时器倒计时结束后，会把Future.delayed带的那个回调函数放到宏任务队列里，此时因为没有立即执行事件了，所以Flutter引擎就会去
  宏任务队列里把这个回调拿出来执行，所以打印了222
  4、而等执行完这个回调函数后，会立即把Future.delayed的then监听放进微任务队列里（默认调用了complete），此时因为没有立即执行事件了，所以Flutter引擎就会去
  微任务队列里把这个回调拿出来执行，所以打印了Future.then被触发了
 */
void microTask() {
  debugPrint("111");

  Future.delayed(const Duration(milliseconds: 0), () {
    debugPrint("222");
  }).then((value) {
    debugPrint("Future.then被触发了");
  });

  debugPrint("333");
}

/*
  六、立即执行事件、微任务事件、宏任务事件的执行优先级及事件循环
  立即执行事件：就是我们常规的代码
  微任务事件（一定的时机会被加入到微任务队列里）：主要包含Future.then回调等
  宏任务事件（一定的时机会被加入到宏任务队列里）：主要包含setTimeout、Future.delayed、触摸事件等用户操作的监听函数、UI Rendering等

  立即执行事件 > 微任务事件 > 宏任务事件
  立即执行事件的优先级最高，Flutter引擎肯定是执行完所有的立即执行事件后才会去执行其它事件
  当所有的立即执行事件都执行完毕后，Flutter引擎就会去微任务队列里拿微任务事件来执行，等所有的微任务事件都执行完毕后，才去宏任务队列里拿一个宏任务事件来执行，而等这个宏任务事件执行完毕后不是立马执行下一个宏任务事件，而是会再次去微任务队列里拿微任务事件来执行（因为上一个宏任务事件执行过程中，可能又产生了新的微任务事件），等这一波微任务事件都执行完毕后，再去宏任务队列里拿一个宏任务事件来执行，如此循环......

  而这种一遍一遍不停地检查和执行事件的机制就是JS里面的事件循环（Event Loop）
 */
